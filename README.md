# nonogen
Anna-Samsara Daefler (avd2131)

## Lexical Analysis
I developed a scanner that processes NonoGen source code and outputs a list of tokens. My scanner shows state
transitions with finite automata. Lexical errors in the input program are handled by the parser printing a message
to stderr and advancing to the next character, such that the user can view and correct all lexical errors in one pass.

### Lexical Grammar
The following list provides a lexical specification of rules in order of priority.

1) ('NEW', r'new')
2) ('SPECIFIER', r'design|random')
3) ('FUNCTION', r'print|play')
4) ('METHOD', r'title|hint')
5) ('GRID_SPECIFIER', r'\.|#')
6) ('ARROW', r'->')
7) ('EQUALS', r'=')
8) ('TIMES', r'x')
9) ('IDENTIFIER', r'[a-zA-Z][a-zA-Z0-9]*')
10) ('INTEGER', r'\d+')
11) ('STRING', r'".*"')
12) ('LBRACE', r'{')
13) ('RBRACE', r'}') 
14) ('LPAREN', r'\(')
15) ('RPAREN', r'\)')
16) ('WHITESPACE', r'\s+')

## Syntactic Analysis
I implemented a parser that takes the sequence of tokens generated by my scanner and constructs 
a syntax tree that represents the hierarchical syntactic structure of the source code. I used
recursive descent parsing. If there is an error in parsing, my parser will print a message to 
the user with suggestions to fix the syntax error and will move ahead to the next statement
where it will continue parsing. Therefore, other syntax errors in the program can be detected in
one pass.

### Context-Free Grammar
S --> IDENTIFIER A | FUNCTION ( IDENTIFIER )

A --> EQUALS NEW SPECIFIER { B } | ARROW METHOD ( D )

B --> GRID_SPECIFIER C | INTEGER TIMES INTEGER

C --> GRID_SPECIFIER C | Îµ

D --> STRING | INTEGER

## Executing Compiler
Use the shell script scan.sh to execute the compiler. Please make sure the system has Python3.

```./scan.sh <input_file>```

### Input Programs
Sample input programs can be found under samples/input_programs/ with their corresponding
expected outputs under samples/outputs/. 

* Programs 1, 2, and 3 demonstrate valid input programs.
* Program 4 contains the illegal character '@'. The parser will handle this by skipping the character and printing a
message to the user that there is an unexpected character at the given position. 
* Program 5 has a string that is not terminated. The parser does not know where the string ends, so it prints a message
to the user that there is an unterminated string beginning at a certain position.
* Program 6 demonstrates a syntactic error: the correct syntax is 'game6->title'.
* Program 7 demonstrates another syntactic error. Here the keyword 'new' is missing when creating a game object.